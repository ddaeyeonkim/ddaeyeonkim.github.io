"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6],{381:function(e,n,t){t.r(n),t.d(n,{Head:function(){return E},default:function(){return p}});var l=t(1151),a=t(7294);function r(e){const n=Object.assign({h2:"h2",p:"p",br:"br",pre:"pre",code:"code",h3:"h3",ul:"ul",li:"li",strong:"strong",blockquote:"blockquote"},(0,l.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.h2,null,"Item 14. 변수 타입이 명확하지 않은 경우 확실하게 지정하라"),"\n",a.createElement(n.p,null,"가독성을 위해 코드를 설계할 때 읽는 사람에게 중요한 정보를 숨겨서는 안 된다.",a.createElement(n.br),"\n","코드 정의로 쉽게 이동할 수 없는 깃허브 같은 환경에서도 읽을 수 있다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-kotlin"},"// bad\nval data = getSomeData()\n// good\nval data: UserData = getSomeData()\n")),"\n",a.createElement(n.p,null,"코틀린은 강력한 타입추론 시스템을 가지고 있어서 많은 경우에 타입 생략이 가능하다.",a.createElement(n.br),"\n","그래서 개발할 때 IDE에서 타입 힌트를 표시하도록 설정해서 사용하고 있었다.",a.createElement(n.br),"\n","하지만 책의 내용대로 타입 힌트를 볼 수 없는 환경에서 읽는 사람도 고려해서 적절히 타입을 명시하는 것이 좋겠다."),"\n",a.createElement(n.h2,null,"Item 15. 리시버를 명시적으로 참조하라"),"\n",a.createElement(n.p,null,"스코프 내부에 둘 이상의 리시버가 있는 경우, 리시버를 명시적으로 나타내는 것이 좋다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-kotlin"},'class Node(val name: String) {\n    // 자식 노드 생성\n    fun makeChild(childName: String): Node? =\n        create("$name.$childName")  // Node("parent.child")\n            .apply { print("Created ${name}") }  // print("Created parent")\n\n    fun create(name: String): Node? = Node(name)\n}\n\nfun main() {\n    val node = Node("parent")\n    node.makeChild("child")\n}\n\n// 결과\n// Create parent\n')),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"create")," 메서드의 리턴타입이 nullable이어서 apply 블록에서 호출한 ",a.createElement(n.code,null,"name"),"은 parent의 name을 참조하게 되었다."),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,"의도대로 동작하도록 고친다면 다음과 같다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-kotlin"},'fun makeChild(childName: String): Node? =\n    create("$name.$childName")  // Node("parent.child")\n        .apply { print("Created ${this?.name}") }  // print("Created parent.child")\n')),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,"nullable을 처리할 때는 let이나 also를 사용하는 것이 더 좋다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-kotlin"},'fun makeChild(childName: String): Node? =\n    create("$name.$childName")  // Node("parent.child")\n        .also { print("Created ${it?.name}") }  // print("Created parent.child")\n')),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,"리시버가 명확하지 않다면, 명시적으로 리시버를 지정하자."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-kotlin"},'fun makeChild(childName: String): Node? =\n    create("$name.$childName")  // Node("parent.child")\n        .apply { print("Created ${this?.name} in ${this@Node.name}") } // print("Created parent.child in parent")"\n')),"\n",a.createElement(n.h3,null,"DSL 마커"),"\n",a.createElement(n.p,null,"암묵적으로 외부 리시버를 사용하는 것을 막는 ",a.createElement(n.code,null,"DslMarker")," 메타 어노테이션(어노테이션을 위한 어노테이션).\nDsl 설계에 따라서 사용 여부를 결정하는 것이 좋다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-kotlin"},'@DslMarker\nannotation class HtmlDsl\n\nfun table(f: TableDsl.() -> Unit) { /* .. */ }\n\n@HtmlDsl\nclass TableDsl { /* .. */ }\n\ntable {\n  tr {\n    td { +"Column 1" }\n    td { +"Column 2" }\n    tr { /* .. */ } // 컴파일 에러\n    this@table.tr { /* .. */ } // 명시적 리시버 사용\n  }\n}\n')),"\n",a.createElement(n.h2,null,"Item 16. 프로퍼티는 동작이 아니라 상태를 나타내야 한다"),"\n",a.createElement(n.p,null,"코틀린의 프로퍼티는 사용자 정의 게터, 세터를 가질 수 있다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-kotlin"},"var name: String? = null\n    get() = field?.toUpperCase()\n    set(value) {\n        if (!value.isNullOrBlank()) {\n            field = value\n        }\n    }\n")),"\n",a.createElement(n.p,null,"위 코드에서 field는 프로퍼티의 데이터를 저장해두는 백킹 필드(backing field)에 대한 레퍼런스이다."),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,"프로퍼티는 필드가 필요 없다. 오히려 프로퍼티는 개념적으로 접근자를 나타낸다."),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"val의 경우 게터"),"\n",a.createElement(n.li,null,"var의 경우 게터와 세터\n따라서 코틀린은 인터페이스에도 프로퍼티를 정의할 수 있다."),"\n"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-kotlin"},"interface Person {\n    val name: String\n}\n")),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,"마찬가지의 이유로 프로퍼티를 위임할 수도 있다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-kotlin"},"val db = Database by lazy { connectToDb() }\n")),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,"프로퍼티는 본질적으로 함수이므로 확장 프로퍼티를 만들 수도 있다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-kotlin"},"val Context.preferences: SharedPreferences\n    get() = PreferenceManager.getDefaultSharedPreferences(this)\n")),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,"프로퍼티를 함수 대신 사용할 수 있지만, 완전히 대체하는 것은 좋지 않다.",a.createElement(n.br),"\n","관습적으로 프로퍼티의 게터에서 무거운 연산 작업을 할 것이라고 예상하지 않기 때문이다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-kotlin"},"// bad\nval Tree<Int>.sum: Int\n    get() = when (this) {\n        is Leaf -> value\n        is Node -> left.sum + right.sum\n    }\n")),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"어떤 것을 프로퍼티로 해야하는지 판단하기 위한 질문")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"이 프로퍼티를 함수로 정의할 경우, 접두사로 get 또는 set을 붙일 것인가?",a.createElement(n.br),"\n","만약 아니라면, 프로퍼티로 만드는 것은 좋지 않다."),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"프로퍼티 대신 함수를 사용하는 것이 좋은 경우")),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"연산 비용이 높거나, 복잡도가 O(1)보다 큰 경우"),"\n",a.createElement(n.li,null,"비즈니스 로직(애플리케이션의 동작)을 포함하는 경우"),"\n",a.createElement(n.li,null,"결정적이지 않은 경우"),"\n",a.createElement(n.li,null,"변환의 경우"),"\n",a.createElement(n.li,null,"게터에서 프로퍼티의 상태 변경이 일어나야 하는 경우"),"\n"),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,"특별한 이유가 없다면 함수를 사용하지 말자."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-kotlin"},'// bad\nclass UserIncorrect {\n    private var name: String = ""\n\n    fun getName() = name\n\n    fun setName(name: String) {\n        this.name = name\n    }\n}\n\n// good\nclass UserCorrect {\n    var name: String = ""\n}\n')))}var c=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?a.createElement(n,e,a.createElement(r,e)):r(e)},m=t(8070),u=t(3673),i=t(9861),o=t(112),d=t(917);const s=e=>{let{data:n,children:t}=e;return(0,d.tZ)(u.Z,null,(0,d.tZ)(i.Z,{title:n.mdx.frontmatter.title,date:n.mdx.frontmatter.date,categories:n.mdx.frontmatter.categories}),(0,d.tZ)(o.Z,null,t))},E=e=>{let{data:n}=e;return(0,d.tZ)(m.Z,{title:n.mdx.frontmatter.title})};function p(e){return a.createElement(s,e,a.createElement(c,e))}}}]);
//# sourceMappingURL=component---src-pages-mdx-frontmatter-slug-tsx-content-file-path-reading-contents-effective-kotlin-items-14-to-16-mdx-54057a326bb6a12fd4fe.js.map